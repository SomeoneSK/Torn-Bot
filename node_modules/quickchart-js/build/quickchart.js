var QuickChart = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/axios/lib/helpers/bind.js
  var require_bind = __commonJS({
    "node_modules/axios/lib/helpers/bind.js"(exports, module) {
      "use strict";
      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };
    }
  });

  // node_modules/axios/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/axios/lib/utils.js"(exports, module) {
      "use strict";
      var bind = require_bind();
      var toString = Object.prototype.toString;
      function isArray(val) {
        return toString.call(val) === "[object Array]";
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer(val) {
        return toString.call(val) === "[object ArrayBuffer]";
      }
      function isFormData(val) {
        return typeof FormData !== "undefined" && val instanceof FormData;
      }
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && val.buffer instanceof ArrayBuffer;
        }
        return result;
      }
      function isString(val) {
        return typeof val === "string";
      }
      function isNumber(val) {
        return typeof val === "number";
      }
      function isObject(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject(val) {
        if (toString.call(val) !== "[object Object]") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      function isDate(val) {
        return toString.call(val) === "[object Date]";
      }
      function isFile(val) {
        return toString.call(val) === "[object File]";
      }
      function isBlob(val) {
        return toString.call(val) === "[object Blob]";
      }
      function isFunction(val) {
        return toString.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject(val) && isFunction(val.pipe);
      }
      function isURLSearchParams(val) {
        return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }
      function extend(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }
      function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      module.exports = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isObject,
        isPlainObject,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isFunction,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge,
        extend,
        trim,
        stripBOM
      };
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  var require_buildURL = __commonJS({
    "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module.exports = function buildURL(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var require_InterceptorManager = __commonJS({
    "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function InterceptorManager() {
        this.handlers = [];
      }
      InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };
      module.exports = InterceptorManager;
    }
  });

  // node_modules/axios/lib/helpers/normalizeHeaderName.js
  var require_normalizeHeaderName = __commonJS({
    "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };
    }
  });

  // node_modules/axios/lib/core/enhanceError.js
  var require_enhanceError = __commonJS({
    "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
      "use strict";
      module.exports = function enhanceError(error, config, code, request, response) {
        error.config = config;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code
          };
        };
        return error;
      };
    }
  });

  // node_modules/axios/lib/core/createError.js
  var require_createError = __commonJS({
    "node_modules/axios/lib/core/createError.js"(exports, module) {
      "use strict";
      var enhanceError = require_enhanceError();
      module.exports = function createError(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
      };
    }
  });

  // node_modules/axios/lib/core/settle.js
  var require_settle = __commonJS({
    "node_modules/axios/lib/core/settle.js"(exports, module) {
      "use strict";
      var createError = require_createError();
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
        }
      };
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var require_cookies = __commonJS({
    "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }();
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  var require_isAbsoluteURL = __commonJS({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
      "use strict";
      module.exports = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
      };
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  var require_combineURLs = __commonJS({
    "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
      "use strict";
      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  var require_buildFullPath = __commonJS({
    "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
      "use strict";
      var isAbsoluteURL = require_isAbsoluteURL();
      var combineURLs = require_combineURLs();
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var require_parseHeaders = __commonJS({
    "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var require_isURLSameOrigin = __commonJS({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  var require_xhr = __commonJS({
    "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var settle = require_settle();
      var cookies = require_cookies();
      var buildURL = require_buildURL();
      var buildFullPath = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var createError = require_createError();
      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(resolve, reject, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken) {
            config.cancelToken.promise.then(function onCanceled(cancel) {
              if (!request) {
                return;
              }
              request.abort();
              reject(cancel);
              request = null;
            });
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
    }
  });

  // node_modules/axios/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/axios/lib/defaults.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var normalizeHeaderName = require_normalizeHeaderName();
      var enhanceError = require_enhanceError();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      var defaults = {
        transitional: {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        },
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data.toString();
          }
          if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return JSON.stringify(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          var transitional = this.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw enhanceError(e, this, "E_JSON_PARSE");
                }
                throw e;
              }
            }
          }
          return data;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        }
      };
      defaults.headers = {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module.exports = defaults;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  var require_transformData = __commonJS({
    "node_modules/axios/lib/core/transformData.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var defaults = require_defaults();
      module.exports = function transformData(data, headers, fns) {
        var context = this || defaults;
        utils.forEach(fns, function transform(fn) {
          data = fn.call(context, data, headers);
        });
        return data;
      };
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  var require_isCancel = __commonJS({
    "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
      "use strict";
      module.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  var require_dispatchRequest = __commonJS({
    "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var transformData = require_transformData();
      var isCancel = require_isCancel();
      var defaults = require_defaults();
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
      }
      module.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = config.headers || {};
        config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
        config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
        utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
          delete config.headers[method];
        });
        var adapter = config.adapter || defaults.adapter;
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  var require_mergeConfig = __commonJS({
    "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config = {};
        var valueFromConfig2Keys = ["url", "method", "data"];
        var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
        var defaultToConfig2Keys = [
          "baseURL",
          "transformRequest",
          "transformResponse",
          "paramsSerializer",
          "timeout",
          "timeoutMessage",
          "withCredentials",
          "adapter",
          "responseType",
          "xsrfCookieName",
          "xsrfHeaderName",
          "onUploadProgress",
          "onDownloadProgress",
          "decompress",
          "maxContentLength",
          "maxBodyLength",
          "maxRedirects",
          "transport",
          "httpAgent",
          "httpsAgent",
          "cancelToken",
          "socketPath",
          "responseEncoding"
        ];
        var directMergeKeys = ["validateStatus"];
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(void 0, config1[prop]);
          }
        }
        utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(void 0, config2[prop]);
          }
        });
        utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
        utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(void 0, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(void 0, config1[prop]);
          }
        });
        utils.forEach(directMergeKeys, function merge(prop) {
          if (prop in config2) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            config[prop] = getMergedValue(void 0, config1[prop]);
          }
        });
        var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
        var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });
        utils.forEach(otherKeys, mergeDeepProperties);
        return config;
      };
    }
  });

  // node_modules/axios/package.json
  var require_package = __commonJS({
    "node_modules/axios/package.json"(exports, module) {
      module.exports = {
        name: "axios",
        version: "0.21.2",
        description: "Promise based HTTP client for the browser and node.js",
        main: "index.js",
        scripts: {
          test: "grunt test",
          start: "node ./sandbox/server.js",
          build: "NODE_ENV=production grunt build",
          preversion: "npm test",
          version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
          postversion: "git push && git push --tags",
          examples: "node ./examples/server.js",
          coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
          fix: "eslint --fix lib/**/*.js"
        },
        repository: {
          type: "git",
          url: "https://github.com/axios/axios.git"
        },
        keywords: [
          "xhr",
          "http",
          "ajax",
          "promise",
          "node"
        ],
        author: "Matt Zabriskie",
        license: "MIT",
        bugs: {
          url: "https://github.com/axios/axios/issues"
        },
        homepage: "https://axios-http.com",
        devDependencies: {
          coveralls: "^3.0.0",
          "es6-promise": "^4.2.4",
          grunt: "^1.3.0",
          "grunt-banner": "^0.6.0",
          "grunt-cli": "^1.2.0",
          "grunt-contrib-clean": "^1.1.0",
          "grunt-contrib-watch": "^1.0.0",
          "grunt-eslint": "^23.0.0",
          "grunt-karma": "^4.0.0",
          "grunt-mocha-test": "^0.13.3",
          "grunt-ts": "^6.0.0-beta.19",
          "grunt-webpack": "^4.0.2",
          "istanbul-instrumenter-loader": "^1.0.0",
          "jasmine-core": "^2.4.1",
          karma: "^6.3.2",
          "karma-chrome-launcher": "^3.1.0",
          "karma-firefox-launcher": "^2.1.0",
          "karma-jasmine": "^1.1.1",
          "karma-jasmine-ajax": "^0.1.13",
          "karma-safari-launcher": "^1.0.0",
          "karma-sauce-launcher": "^4.3.6",
          "karma-sinon": "^1.0.5",
          "karma-sourcemap-loader": "^0.3.8",
          "karma-webpack": "^4.0.2",
          "load-grunt-tasks": "^3.5.2",
          minimist: "^1.2.0",
          mocha: "^8.2.1",
          sinon: "^4.5.0",
          "terser-webpack-plugin": "^4.2.3",
          typescript: "^4.0.5",
          "url-search-params": "^0.10.0",
          webpack: "^4.44.2",
          "webpack-dev-server": "^3.11.0"
        },
        browser: {
          "./lib/adapters/http.js": "./lib/adapters/xhr.js"
        },
        jsdelivr: "dist/axios.min.js",
        unpkg: "dist/axios.min.js",
        typings: "./index.d.ts",
        dependencies: {
          "follow-redirects": "^1.14.0"
        },
        bundlesize: [
          {
            path: "./dist/axios.min.js",
            threshold: "5kB"
          }
        ]
      };
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  var require_validator = __commonJS({
    "node_modules/axios/lib/helpers/validator.js"(exports, module) {
      "use strict";
      var pkg = require_package();
      var validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      var currentVerArr = pkg.version.split(".");
      function isOlderVersion(version, thanVersion) {
        var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
        var destVer = version.split(".");
        for (var i = 0; i < 3; i++) {
          if (pkgVersionArr[i] > destVer[i]) {
            return true;
          } else if (pkgVersionArr[i] < destVer[i]) {
            return false;
          }
        }
        return false;
      }
      validators.transitional = function transitional(validator, version, message) {
        var isDeprecated = version && isOlderVersion(version);
        function formatMessage(opt, desc) {
          return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator === false) {
            throw new Error(formatMessage(opt, " has been removed in " + version));
          }
          if (isDeprecated && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
          }
          return validator ? validator(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var i = keys.length;
        while (i-- > 0) {
          var opt = keys[i];
          var validator = schema[opt];
          if (validator) {
            var value = options[opt];
            var result = value === void 0 || validator(value, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      module.exports = {
        isOlderVersion,
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var require_Axios = __commonJS({
    "node_modules/axios/lib/core/Axios.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var buildURL = require_buildURL();
      var InterceptorManager = require_InterceptorManager();
      var dispatchRequest = require_dispatchRequest();
      var mergeConfig = require_mergeConfig();
      var validator = require_validator();
      var validators = validator.validators;
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios.prototype.request = function request(config) {
        if (typeof config === "string") {
          config = arguments[1] || {};
          config.url = arguments[0];
        } else {
          config = config || {};
        }
        config = mergeConfig(this.defaults, config);
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }
        var transitional = config.transitional;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
            forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
            clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios.prototype.getUri = function getUri(config) {
        config = mergeConfig(this.defaults, config);
        return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        Axios.prototype[method] = function(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data
          }));
        };
      });
      module.exports = Axios;
    }
  });

  // node_modules/axios/lib/cancel/Cancel.js
  var require_Cancel = __commonJS({
    "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
      "use strict";
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      module.exports = Cancel;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var require_CancelToken = __commonJS({
    "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
      "use strict";
      var Cancel = require_Cancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      };
      module.exports = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  var require_spread = __commonJS({
    "node_modules/axios/lib/helpers/spread.js"(exports, module) {
      "use strict";
      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  var require_isAxiosError = __commonJS({
    "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
      "use strict";
      module.exports = function isAxiosError(payload) {
        return typeof payload === "object" && payload.isAxiosError === true;
      };
    }
  });

  // node_modules/axios/lib/axios.js
  var require_axios = __commonJS({
    "node_modules/axios/lib/axios.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var bind = require_bind();
      var Axios = require_Axios();
      var mergeConfig = require_mergeConfig();
      var defaults = require_defaults();
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);
        utils.extend(instance, Axios.prototype, context);
        utils.extend(instance, context);
        return instance;
      }
      var axios2 = createInstance(defaults);
      axios2.Axios = Axios;
      axios2.create = function create(instanceConfig) {
        return createInstance(mergeConfig(axios2.defaults, instanceConfig));
      };
      axios2.Cancel = require_Cancel();
      axios2.CancelToken = require_CancelToken();
      axios2.isCancel = require_isCancel();
      axios2.all = function all(promises) {
        return Promise.all(promises);
      };
      axios2.spread = require_spread();
      axios2.isAxiosError = require_isAxiosError();
      module.exports = axios2;
      module.exports.default = axios2;
    }
  });

  // node_modules/axios/index.js
  var require_axios2 = __commonJS({
    "node_modules/axios/index.js"(exports, module) {
      module.exports = require_axios();
    }
  });

  // node_modules/javascript-stringify/dist/quote.js
  var require_quote = __commonJS({
    "node_modules/javascript-stringify/dist/quote.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ESCAPABLE = /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var META_CHARS = /* @__PURE__ */ new Map([
        ["\b", "\\b"],
        ["	", "\\t"],
        ["\n", "\\n"],
        ["\f", "\\f"],
        ["\r", "\\r"],
        ["'", "\\'"],
        ['"', '\\"'],
        ["\\", "\\\\"]
      ]);
      function escapeChar(char) {
        return META_CHARS.get(char) || `\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`;
      }
      function quoteString(str) {
        return `'${str.replace(ESCAPABLE, escapeChar)}'`;
      }
      exports.quoteString = quoteString;
      var RESERVED_WORDS = new Set("break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield".split(" "));
      exports.IS_VALID_IDENTIFIER = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
      function isValidVariableName(name) {
        return typeof name === "string" && !RESERVED_WORDS.has(name) && exports.IS_VALID_IDENTIFIER.test(name);
      }
      exports.isValidVariableName = isValidVariableName;
      function quoteKey(key, next) {
        return isValidVariableName(key) ? key : next(key);
      }
      exports.quoteKey = quoteKey;
      function stringifyPath(path, next) {
        let result = "";
        for (const key of path) {
          if (isValidVariableName(key)) {
            result += `.${key}`;
          } else {
            result += `[${next(key)}]`;
          }
        }
        return result;
      }
      exports.stringifyPath = stringifyPath;
    }
  });

  // node_modules/javascript-stringify/dist/function.js
  var require_function = __commonJS({
    "node_modules/javascript-stringify/dist/function.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var quote_1 = require_quote();
      var METHOD_NAMES_ARE_QUOTED = {
        " "() {
        }
      }[" "].toString().charAt(0) === '"';
      var FUNCTION_PREFIXES = {
        Function: "function ",
        GeneratorFunction: "function* ",
        AsyncFunction: "async function ",
        AsyncGeneratorFunction: "async function* "
      };
      var METHOD_PREFIXES = {
        Function: "",
        GeneratorFunction: "*",
        AsyncFunction: "async ",
        AsyncGeneratorFunction: "async *"
      };
      var TOKENS_PRECEDING_REGEXPS = new Set("case delete else in instanceof new return throw typeof void , ; : + - ! ~ & | ^ * / % < > ? =".split(" "));
      exports.USED_METHOD_KEY = new WeakSet();
      exports.functionToString = (fn, space, next, key) => {
        const name = typeof key === "string" ? key : void 0;
        if (name !== void 0)
          exports.USED_METHOD_KEY.add(fn);
        return new FunctionParser(fn, space, next, name).stringify();
      };
      function dedentFunction(fnString) {
        let found;
        for (const line of fnString.split("\n").slice(1)) {
          const m = /^[\s\t]+/.exec(line);
          if (!m)
            return fnString;
          const [str] = m;
          if (found === void 0)
            found = str;
          else if (str.length < found.length)
            found = str;
        }
        return found ? fnString.split(`
${found}`).join("\n") : fnString;
      }
      exports.dedentFunction = dedentFunction;
      var FunctionParser = class {
        constructor(fn, indent, next, key) {
          this.fn = fn;
          this.indent = indent;
          this.next = next;
          this.key = key;
          this.pos = 0;
          this.hadKeyword = false;
          this.fnString = Function.prototype.toString.call(fn);
          this.fnType = fn.constructor.name;
          this.keyQuote = key === void 0 ? "" : quote_1.quoteKey(key, next);
          this.keyPrefix = key === void 0 ? "" : `${this.keyQuote}:${indent ? " " : ""}`;
          this.isMethodCandidate = key === void 0 ? false : this.fn.name === "" || this.fn.name === key;
        }
        stringify() {
          const value = this.tryParse();
          if (!value) {
            return `${this.keyPrefix}void ${this.next(this.fnString)}`;
          }
          return dedentFunction(value);
        }
        getPrefix() {
          if (this.isMethodCandidate && !this.hadKeyword) {
            return METHOD_PREFIXES[this.fnType] + this.keyQuote;
          }
          return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];
        }
        tryParse() {
          if (this.fnString[this.fnString.length - 1] !== "}") {
            return this.keyPrefix + this.fnString;
          }
          if (this.fn.name) {
            const result = this.tryStrippingName();
            if (result)
              return result;
          }
          const prevPos = this.pos;
          if (this.consumeSyntax() === "class")
            return this.fnString;
          this.pos = prevPos;
          if (this.tryParsePrefixTokens()) {
            const result = this.tryStrippingName();
            if (result)
              return result;
            let offset = this.pos;
            switch (this.consumeSyntax("WORD_LIKE")) {
              case "WORD_LIKE":
                if (this.isMethodCandidate && !this.hadKeyword) {
                  offset = this.pos;
                }
              case "()":
                if (this.fnString.substr(this.pos, 2) === "=>") {
                  return this.keyPrefix + this.fnString;
                }
                this.pos = offset;
              case '"':
              case "'":
              case "[]":
                return this.getPrefix() + this.fnString.substr(this.pos);
            }
          }
        }
        tryStrippingName() {
          if (METHOD_NAMES_ARE_QUOTED) {
            return;
          }
          let start = this.pos;
          const prefix = this.fnString.substr(this.pos, this.fn.name.length);
          if (prefix === this.fn.name) {
            this.pos += prefix.length;
            if (this.consumeSyntax() === "()" && this.consumeSyntax() === "{}" && this.pos === this.fnString.length) {
              if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {
                start += prefix.length;
              }
              return this.getPrefix() + this.fnString.substr(start);
            }
          }
          this.pos = start;
        }
        tryParsePrefixTokens() {
          let posPrev = this.pos;
          this.hadKeyword = false;
          switch (this.fnType) {
            case "AsyncFunction":
              if (this.consumeSyntax() !== "async")
                return false;
              posPrev = this.pos;
            case "Function":
              if (this.consumeSyntax() === "function") {
                this.hadKeyword = true;
              } else {
                this.pos = posPrev;
              }
              return true;
            case "AsyncGeneratorFunction":
              if (this.consumeSyntax() !== "async")
                return false;
            case "GeneratorFunction":
              let token = this.consumeSyntax();
              if (token === "function") {
                token = this.consumeSyntax();
                this.hadKeyword = true;
              }
              return token === "*";
          }
        }
        consumeSyntax(wordLikeToken) {
          const m = this.consumeMatch(/^(?:([A-Za-z_0-9$\xA0-\uFFFF]+)|=>|\+\+|\-\-|.)/);
          if (!m)
            return;
          const [token, match] = m;
          this.consumeWhitespace();
          if (match)
            return wordLikeToken || match;
          switch (token) {
            case "(":
              return this.consumeSyntaxUntil("(", ")");
            case "[":
              return this.consumeSyntaxUntil("[", "]");
            case "{":
              return this.consumeSyntaxUntil("{", "}");
            case "`":
              return this.consumeTemplate();
            case '"':
              return this.consumeRegExp(/^(?:[^\\"]|\\.)*"/, '"');
            case "'":
              return this.consumeRegExp(/^(?:[^\\']|\\.)*'/, "'");
          }
          return token;
        }
        consumeSyntaxUntil(startToken, endToken) {
          let isRegExpAllowed = true;
          for (; ; ) {
            const token = this.consumeSyntax();
            if (token === endToken)
              return startToken + endToken;
            if (!token || token === ")" || token === "]" || token === "}")
              return;
            if (token === "/" && isRegExpAllowed && this.consumeMatch(/^(?:\\.|[^\\\/\n[]|\[(?:\\.|[^\]])*\])+\/[a-z]*/)) {
              isRegExpAllowed = false;
              this.consumeWhitespace();
            } else {
              isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);
            }
          }
        }
        consumeMatch(re) {
          const m = re.exec(this.fnString.substr(this.pos));
          if (m)
            this.pos += m[0].length;
          return m;
        }
        consumeRegExp(re, token) {
          const m = re.exec(this.fnString.substr(this.pos));
          if (!m)
            return;
          this.pos += m[0].length;
          this.consumeWhitespace();
          return token;
        }
        consumeTemplate() {
          for (; ; ) {
            this.consumeMatch(/^(?:[^`$\\]|\\.|\$(?!{))*/);
            if (this.fnString[this.pos] === "`") {
              this.pos++;
              this.consumeWhitespace();
              return "`";
            }
            if (this.fnString.substr(this.pos, 2) === "${") {
              this.pos += 2;
              this.consumeWhitespace();
              if (this.consumeSyntaxUntil("{", "}"))
                continue;
            }
            return;
          }
        }
        consumeWhitespace() {
          this.consumeMatch(/^(?:\s|\/\/.*|\/\*[^]*?\*\/)*/);
        }
      };
      exports.FunctionParser = FunctionParser;
    }
  });

  // node_modules/javascript-stringify/dist/array.js
  var require_array = __commonJS({
    "node_modules/javascript-stringify/dist/array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.arrayToString = (array, space, next) => {
        const values = array.map(function(value, index) {
          const result = next(value, index);
          if (result === void 0)
            return String(result);
          return space + result.split("\n").join(`
${space}`);
        }).join(space ? ",\n" : ",");
        const eol = space && values ? "\n" : "";
        return `[${eol}${values}${eol}]`;
      };
    }
  });

  // node_modules/javascript-stringify/dist/object.js
  var require_object = __commonJS({
    "node_modules/javascript-stringify/dist/object.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var quote_1 = require_quote();
      var function_1 = require_function();
      var array_1 = require_array();
      exports.objectToString = (value, space, next, key) => {
        if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
          return `new Buffer(${next(value.toString())})`;
        }
        const toString = OBJECT_TYPES[Object.prototype.toString.call(value)];
        return toString ? toString(value, space, next, key) : void 0;
      };
      var rawObjectToString = (obj, indent, next) => {
        const eol = indent ? "\n" : "";
        const space = indent ? " " : "";
        const values = Object.keys(obj).reduce(function(values2, key) {
          const fn = obj[key];
          const result = next(fn, key);
          if (result === void 0)
            return values2;
          const value = result.split("\n").join(`
${indent}`);
          if (function_1.USED_METHOD_KEY.has(fn)) {
            values2.push(`${indent}${value}`);
            return values2;
          }
          values2.push(`${indent}${quote_1.quoteKey(key, next)}:${space}${value}`);
          return values2;
        }, []).join(`,${eol}`);
        if (values === "")
          return "{}";
        return `{${eol}${values}${eol}}`;
      };
      var globalToString = (value, space, next) => {
        return `Function(${next("return this")})()`;
      };
      var OBJECT_TYPES = {
        "[object Array]": array_1.arrayToString,
        "[object Object]": rawObjectToString,
        "[object Error]": (error, space, next) => {
          return `new Error(${next(error.message)})`;
        },
        "[object Date]": (date) => {
          return `new Date(${date.getTime()})`;
        },
        "[object String]": (str, space, next) => {
          return `new String(${next(str.toString())})`;
        },
        "[object Number]": (num) => {
          return `new Number(${num})`;
        },
        "[object Boolean]": (bool) => {
          return `new Boolean(${bool})`;
        },
        "[object Set]": (set, space, next) => {
          return `new Set(${next(Array.from(set))})`;
        },
        "[object Map]": (map, space, next) => {
          return `new Map(${next(Array.from(map))})`;
        },
        "[object RegExp]": String,
        "[object global]": globalToString,
        "[object Window]": globalToString
      };
    }
  });

  // node_modules/javascript-stringify/dist/stringify.js
  var require_stringify = __commonJS({
    "node_modules/javascript-stringify/dist/stringify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var quote_1 = require_quote();
      var object_1 = require_object();
      var function_1 = require_function();
      var PRIMITIVE_TYPES = {
        string: quote_1.quoteString,
        number: (value) => Object.is(value, -0) ? "-0" : String(value),
        boolean: String,
        symbol: (value, space, next) => {
          const key = Symbol.keyFor(value);
          if (key !== void 0)
            return `Symbol.for(${next(key)})`;
          return `Symbol(${next(value.description)})`;
        },
        bigint: (value, space, next) => {
          return `BigInt(${next(String(value))})`;
        },
        undefined: String,
        object: object_1.objectToString,
        function: function_1.functionToString
      };
      exports.toString = (value, space, next, key) => {
        if (value === null)
          return "null";
        return PRIMITIVE_TYPES[typeof value](value, space, next, key);
      };
    }
  });

  // node_modules/javascript-stringify/dist/index.js
  var require_dist = __commonJS({
    "node_modules/javascript-stringify/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var stringify_1 = require_stringify();
      var quote_1 = require_quote();
      var ROOT_SENTINEL = Symbol("root");
      function stringify2(value, replacer, indent, options = {}) {
        const space = typeof indent === "string" ? indent : " ".repeat(indent || 0);
        const path = [];
        const stack = /* @__PURE__ */ new Set();
        const tracking = /* @__PURE__ */ new Map();
        const unpack = /* @__PURE__ */ new Map();
        let valueCount = 0;
        const { maxDepth = 100, references = false, skipUndefinedProperties = false, maxValues = 1e5 } = options;
        const valueToString = replacerToString(replacer);
        const onNext = (value2, key) => {
          if (++valueCount > maxValues)
            return;
          if (skipUndefinedProperties && value2 === void 0)
            return;
          if (path.length > maxDepth)
            return;
          if (key === void 0)
            return valueToString(value2, space, onNext, key);
          path.push(key);
          const result2 = builder(value2, key === ROOT_SENTINEL ? void 0 : key);
          path.pop();
          return result2;
        };
        const builder = references ? (value2, key) => {
          if (value2 !== null && (typeof value2 === "object" || typeof value2 === "function" || typeof value2 === "symbol")) {
            if (tracking.has(value2)) {
              unpack.set(path.slice(1), tracking.get(value2));
              return;
            }
            tracking.set(value2, path.slice(1));
          }
          return valueToString(value2, space, onNext, key);
        } : (value2, key) => {
          if (stack.has(value2))
            return;
          stack.add(value2);
          const result2 = valueToString(value2, space, onNext, key);
          stack.delete(value2);
          return result2;
        };
        const result = onNext(value, ROOT_SENTINEL);
        if (unpack.size) {
          const sp = space ? " " : "";
          const eol = space ? "\n" : "";
          let wrapper = `var x${sp}=${sp}${result};${eol}`;
          for (const [key, value2] of unpack.entries()) {
            const keyPath = quote_1.stringifyPath(key, onNext);
            const valuePath = quote_1.stringifyPath(value2, onNext);
            wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;
          }
          return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;
        }
        return result;
      }
      exports.stringify = stringify2;
      function replacerToString(replacer) {
        if (!replacer)
          return stringify_1.toString;
        return (value, space, next, key) => {
          return replacer(value, space, (value2) => stringify_1.toString(value2, space, next, key), key);
        };
      }
    }
  });

  // src/index.ts
  function doStringify(chartConfig) {
    const str = (0, import_javascript_stringify.stringify)(chartConfig);
    if (!str) {
      return void 0;
    }
    return str.replace(SPECIAL_FUNCTION_REGEX, "$1");
  }
  var import_axios, import_javascript_stringify, SPECIAL_FUNCTION_REGEX, QuickChart, src_default;
  var init_src = __esm({
    "src/index.ts"() {
      import_axios = __toModule(require_axios2());
      import_javascript_stringify = __toModule(require_dist());
      SPECIAL_FUNCTION_REGEX = /['"]__BEGINFUNCTION__(.*?)__ENDFUNCTION__['"]/g;
      QuickChart = class {
        constructor(apiKey, accountId) {
          this.apiKey = apiKey;
          this.accountId = accountId;
          this.host = "quickchart.io";
          this.protocol = "https";
          this.baseUrl = `${this.protocol}://${this.host}`;
          this.chart = void 0;
          this.width = 500;
          this.height = 300;
          this.devicePixelRatio = 1;
          this.backgroundColor = "#ffffff";
          this.format = "png";
          this.version = "2.9.4";
        }
        setConfig(chartConfig) {
          this.chart = typeof chartConfig === "string" ? chartConfig : doStringify(chartConfig);
          return this;
        }
        setWidth(width) {
          this.width = width;
          return this;
        }
        setHeight(height) {
          this.height = height;
          return this;
        }
        setBackgroundColor(color) {
          this.backgroundColor = color;
          return this;
        }
        setDevicePixelRatio(ratio) {
          this.devicePixelRatio = ratio;
          return this;
        }
        setFormat(fmt) {
          this.format = fmt;
          return this;
        }
        setVersion(version) {
          this.version = version;
          return this;
        }
        isValid() {
          if (!this.chart) {
            return false;
          }
          return true;
        }
        getUrlObject() {
          if (!this.isValid()) {
            throw new Error("You must call setConfig before getUrl");
          }
          const ret = new URL(`${this.baseUrl}/chart`);
          ret.searchParams.append("c", this.chart);
          ret.searchParams.append("w", String(this.width));
          ret.searchParams.append("h", String(this.height));
          if (this.devicePixelRatio !== 1) {
            ret.searchParams.append("devicePixelRatio", String(this.devicePixelRatio));
          }
          if (this.backgroundColor) {
            ret.searchParams.append("bkg", this.backgroundColor);
          }
          if (this.format) {
            ret.searchParams.append("f", this.format);
          }
          if (this.version) {
            ret.searchParams.append("v", this.version);
          }
          if (this.apiKey) {
            ret.searchParams.append("key", this.apiKey);
          }
          return ret;
        }
        getUrl() {
          return this.getUrlObject().href;
        }
        getSignedUrl() {
          if (!this.accountId || !this.apiKey) {
            throw new Error("You must set accountId and apiKey in the QuickChart constructor to use getSignedUrl()");
          }
          const crypto = __require("crypto");
          const urlObj = this.getUrlObject();
          const chartStr = urlObj.searchParams.get("c");
          const signature = crypto.createHmac("sha256", this.apiKey).update(chartStr).digest("hex");
          urlObj.searchParams.append("sig", signature);
          urlObj.searchParams.append("accountId", this.accountId);
          urlObj.searchParams.delete("key");
          return urlObj.href;
        }
        getPostData() {
          if (!this.isValid()) {
            throw new Error("You must call setConfig creating post data");
          }
          const { width, height, chart, format, version, backgroundColor, devicePixelRatio, apiKey } = this;
          const postData = {
            width,
            height,
            chart
          };
          if (format) {
            postData.format = format;
          }
          if (version) {
            postData.version = version;
          }
          if (backgroundColor) {
            postData.backgroundColor = backgroundColor;
          }
          if (devicePixelRatio) {
            postData.devicePixelRatio = devicePixelRatio;
          }
          if (apiKey) {
            postData.key = apiKey;
          }
          return postData;
        }
        getShortUrl() {
          return __async(this, null, function* () {
            if (!this.isValid()) {
              throw new Error("You must call setConfig before getUrl");
            }
            if (this.host !== "quickchart.io") {
              throw new Error("Short URLs must use quickchart.io host");
            }
            const resp = yield import_axios.default.post(`${this.baseUrl}/chart/create`, this.getPostData());
            if (resp.status !== 200) {
              throw `Bad response code ${resp.status} from chart shorturl endpoint`;
            } else if (!resp.data.success) {
              throw "Received failure response from chart shorturl endpoint";
            } else {
              return resp.data.url;
            }
          });
        }
        toBinary() {
          return __async(this, null, function* () {
            if (!this.isValid()) {
              throw new Error("You must call setConfig before getUrl");
            }
            const resp = yield import_axios.default.post(`${this.baseUrl}/chart`, this.getPostData(), {
              responseType: "arraybuffer"
            });
            if (resp.status !== 200) {
              throw `Bad response code ${resp.status} from chart shorturl endpoint`;
            }
            return Buffer.from(resp.data, "binary");
          });
        }
        toDataUrl() {
          return __async(this, null, function* () {
            const buf = yield this.toBinary();
            const b64buf = buf.toString("base64");
            const type = this.format === "svg" ? "svg+xml" : "png";
            return `data:image/${type};base64,${b64buf}`;
          });
        }
        toFile(pathOrDescriptor) {
          return __async(this, null, function* () {
            const fs = __require("fs");
            const buf = yield this.toBinary();
            fs.writeFileSync(pathOrDescriptor, buf);
          });
        }
        static getGradientFillHelper(direction, colors, dimensions) {
          return `__BEGINFUNCTION__getGradientFillHelper(${JSON.stringify(direction)}, ${JSON.stringify(colors)}, ${JSON.stringify(dimensions)})__ENDFUNCTION__`;
        }
        static getGradientFill(colorOptions, linearGradient) {
          return `__BEGINFUNCTION__getGradientFill(${JSON.stringify(colorOptions)}, ${JSON.stringify(linearGradient)})__ENDFUNCTION__`;
        }
        static getImageFill(url) {
          return `__BEGINFUNCTION__getImageFill(${JSON.stringify(url)})__ENDFUNCTION__`;
        }
      };
      QuickChart.pattern = {
        draw: function(shapeType, backgroundColor, patternColor, requestedSize) {
          return `__BEGINFUNCTION__pattern.draw(${JSON.stringify(shapeType)}, ${JSON.stringify(backgroundColor)}, ${JSON.stringify(patternColor)}, ${JSON.stringify(requestedSize)})__ENDFUNCTION__`;
        }
      };
      src_default = QuickChart;
    }
  });

  // src/index.cjs.ts
  var require_index_cjs = __commonJS({
    "src/index.cjs.ts"(exports, module) {
      init_src();
      module.exports = src_default;
    }
  });
  return require_index_cjs();
})();
//# sourceMappingURL=quickchart.js.map
